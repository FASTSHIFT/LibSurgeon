#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LibSurgeon Test Suite

Unit tests for LibSurgeon decompilation tools.
Supports code coverage via pytest-cov.

Usage:
    pytest tests/                           # Run all tests
    pytest tests/ -v                        # Verbose output
    pytest tests/ --cov=. --cov-report=html # With coverage report
"""

import os
import shutil
import subprocess
import tempfile

import pytest

from evaluate_quality import (
    PATTERNS,
    FileMetrics,
    analyze_directory,
    analyze_file,
)
from libsurgeon import (
    MODULE_STRATEGIES,
    Colors,
    FileType,
    draw_progress_bar,
    extract_archive,
    format_time,
    get_file_type,
    is_archive_file,
    is_elf_file,
    matches_pattern,
    show_progress,
    show_progress_final,
)

# Path setup is done in conftest.py


# ============================================================
# Fixtures
# ============================================================


@pytest.fixture
def temp_dir():
    """Create a temporary directory for tests"""
    tmp = tempfile.mkdtemp(prefix="libsurgeon_test_")
    yield tmp
    shutil.rmtree(tmp, ignore_errors=True)


@pytest.fixture
def sample_cpp_file(temp_dir):
    """Create a sample decompiled C++ file"""
    content = """/**
 * Auto-generated decompiled code from: TestModule.o
 * Generated by LibSurgeon (Ghidra-based decompiler)
 */

#include <stdint.h>
#include <stdbool.h>

namespace xxgfx {

// ============================================================
// Class: TestClass
// ============================================================

// Function: testFunction

void __thiscall TestClass::testFunction(TestClass *this, int param_1)
{
    undefined4 local_10;
    local_10 = *(undefined4 *)(this + 8);
    if (param_1 == 0) {
        __assert_fail("param != 0", "framework/source/test.cpp", 42, "void test()");
    }
    return;
}

// Function: anotherFunction

int TestClass::anotherFunction(void)
{
    return *(int *)(this + 0x10);
}

} // namespace xxgfx
"""
    filepath = os.path.join(temp_dir, "TestModule.cpp")
    with open(filepath, "w") as f:
        f.write(content)
    return filepath


@pytest.fixture
def sample_bad_cpp_file(temp_dir):
    """Create a sample decompiled file with quality issues"""
    content = """/**
 * Auto-generated with issues
 */

void bad_function(void)
{
    halt_baddata();
    halt_baddata();
    undefined4 local_10;
    undefined8 local_20;
    undefined local_30;
    goto LAB_001234;
LAB_001234:
    return;
}
"""
    filepath = os.path.join(temp_dir, "BadModule.cpp")
    with open(filepath, "w") as f:
        f.write(content)
    return filepath


@pytest.fixture
def test_archive(temp_dir):
    """Create a minimal test archive if ar is available"""
    # Create a simple C file
    c_file = os.path.join(temp_dir, "test.c")
    with open(c_file, "w") as f:
        f.write("int test_func(void) { return 42; }\n")

    # Compile to object file
    o_file = os.path.join(temp_dir, "test.o")
    try:
        subprocess.run(
            ["gcc", "-c", c_file, "-o", o_file], check=True, capture_output=True
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("gcc not available")

    # Create archive
    a_file = os.path.join(temp_dir, "libtest.a")
    try:
        subprocess.run(["ar", "rcs", a_file, o_file], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("ar not available")

    return a_file


# ============================================================
# Test: File Type Detection
# ============================================================


class TestFileTypeDetection:
    """Tests for file type detection"""

    def test_archive_extensions(self):
        """Test archive file type detection"""
        assert get_file_type("libfoo.a") == FileType.ARCHIVE
        assert get_file_type("libbar.lib") == FileType.ARCHIVE
        assert get_file_type("/path/to/test.a") == FileType.ARCHIVE

    def test_elf_extensions(self):
        """Test ELF file type detection"""
        assert get_file_type("firmware.elf") == FileType.ELF
        assert get_file_type("libfoo.so") == FileType.ELF
        assert get_file_type("module.o") == FileType.ELF
        assert get_file_type("app.axf") == FileType.ELF
        assert get_file_type("program.out") == FileType.ELF

    def test_so_versioned(self):
        """Test versioned .so files"""
        assert get_file_type("libfoo.so.1") == FileType.ELF
        assert get_file_type("libfoo.so.1.2.3") == FileType.ELF

    def test_unknown_extensions(self):
        """Test unknown file types"""
        assert get_file_type("file.txt") == FileType.UNKNOWN
        assert get_file_type("image.png") == FileType.UNKNOWN
        assert get_file_type("code.cpp") == FileType.UNKNOWN


class TestPatternMatching:
    """Tests for pattern matching"""

    def test_exact_match(self):
        """Test exact filename matching"""
        assert matches_pattern("libfoo.a", "libfoo.a") is True
        assert matches_pattern("libfoo.a", "libbar.a") is False

    def test_wildcard_match(self):
        """Test wildcard pattern matching"""
        assert matches_pattern("libfoo.a", "lib*.a") is True
        assert matches_pattern("libfoo.a", "*.a") is True
        assert matches_pattern("libfoo.a", "libfoo.*") is True
        assert matches_pattern("libfoo.a", "*.so") is False

    def test_question_mark(self):
        """Test single character wildcard"""
        assert matches_pattern("libfoo.a", "libfo?.a") is True
        assert matches_pattern("libfoo.a", "lib???.a") is True
        assert matches_pattern("libfoo.a", "lib??.a") is False


class TestTimeFormatting:
    """Tests for time formatting"""

    def test_seconds(self):
        """Test seconds formatting"""
        assert format_time(0) == "0s"
        assert format_time(30) == "30s"
        assert format_time(59) == "59s"

    def test_minutes(self):
        """Test minutes formatting"""
        assert format_time(60) == "1m0s"
        assert format_time(90) == "1m30s"
        assert format_time(3599) == "59m59s"

    def test_hours(self):
        """Test hours formatting"""
        assert format_time(3600) == "1h0m"
        assert format_time(5400) == "1h30m"
        assert format_time(7200) == "2h0m"


class TestProgressBar:
    """Tests for progress bar functions"""

    def test_draw_progress_bar_empty(self):
        """Test empty progress bar"""
        bar = draw_progress_bar(0, 100)
        assert len(bar) == 40
        assert "█" not in bar
        assert bar.count("░") == 40

    def test_draw_progress_bar_full(self):
        """Test full progress bar"""
        bar = draw_progress_bar(100, 100)
        assert len(bar) == 40
        assert bar.count("█") == 40
        assert "░" not in bar

    def test_draw_progress_bar_half(self):
        """Test half-filled progress bar"""
        bar = draw_progress_bar(50, 100)
        assert len(bar) == 40
        assert bar.count("█") == 20
        assert bar.count("░") == 20

    def test_draw_progress_bar_zero_total(self):
        """Test progress bar with zero total"""
        bar = draw_progress_bar(0, 0)
        assert len(bar) == 40
        assert bar.count("░") == 40

    def test_draw_progress_bar_custom_width(self):
        """Test progress bar with custom width"""
        bar = draw_progress_bar(50, 100, width=20)
        assert len(bar) == 20


class TestModuleStrategies:
    """Tests for ELF module grouping strategies"""

    def test_strategies_defined(self):
        """Test that all strategies are defined"""
        assert "prefix" in MODULE_STRATEGIES
        assert "alpha" in MODULE_STRATEGIES
        assert "camelcase" in MODULE_STRATEGIES
        assert "single" in MODULE_STRATEGIES
        assert len(MODULE_STRATEGIES) == 4


# ============================================================
# Test: Quality Evaluation
# ============================================================


class TestQualityEvaluation:
    """Tests for quality evaluation"""

    def test_analyze_good_file(self, sample_cpp_file):
        """Test analyzing a good quality file"""
        metrics = analyze_file(sample_cpp_file)

        assert metrics.halt_baddata == 0
        assert metrics.lines > 0
        assert metrics.quality_score >= 80
        assert "xxgfx" in metrics.namespaces_found

    def test_analyze_bad_file(self, sample_bad_cpp_file):
        """Test analyzing a file with quality issues"""
        metrics = analyze_file(sample_bad_cpp_file)

        assert metrics.halt_baddata == 2
        assert metrics.goto_statements >= 1
        assert metrics.quality_score < 80
        assert len(metrics.issues) > 0

    def test_analyze_directory(self, sample_cpp_file, sample_bad_cpp_file, temp_dir):
        """Test analyzing a directory of files"""
        project = analyze_directory(temp_dir)

        assert project.total_files == 2
        assert project.files_with_halt_baddata == 1
        assert project.total_halt_baddata == 2
        assert 0 <= project.avg_quality_score <= 100

    def test_quality_score_calculation(self):
        """Test quality score calculation"""
        metrics = FileMetrics(filepath="test.cpp", filename="test.cpp")

        # Perfect file
        metrics.halt_baddata = 0
        metrics.undefined_types = 0
        assert metrics.quality_score >= 95

        # File with halt_baddata
        metrics.halt_baddata = 5
        assert metrics.quality_score < 60

    def test_pattern_detection(self):
        """Test regex pattern detection"""
        test_code = """
void test() {
    halt_baddata();
    undefined4 x;
    undefined8 y;
    goto LAB_001;
}
"""
        assert len(PATTERNS["halt_baddata"].findall(test_code)) == 1
        assert len(PATTERNS["undefined_type"].findall(test_code)) == 2
        assert len(PATTERNS["goto"].findall(test_code)) == 1


# ============================================================
# Test: Archive Processing
# ============================================================


class TestArchiveProcessing:
    """Tests for archive processing"""

    def test_extract_archive(self, test_archive, temp_dir):
        """Test archive extraction"""
        extract_dir = os.path.join(temp_dir, "extracted")
        obj_files = extract_archive(test_archive, extract_dir)

        assert len(obj_files) >= 1
        assert any(f.endswith(".o") for f in obj_files)

    def test_is_archive_file(self, test_archive, temp_dir):
        """Test archive magic number detection"""
        assert is_archive_file(test_archive) is True

        # Create a non-archive file
        fake_file = os.path.join(temp_dir, "fake.a")
        with open(fake_file, "w") as f:
            f.write("not an archive")
        assert is_archive_file(fake_file) is False


class TestElfDetection:
    """Tests for ELF file detection"""

    def test_is_elf_file_valid(self, temp_dir):
        """Test valid ELF magic number detection"""
        # Create a file with ELF magic number
        elf_file = os.path.join(temp_dir, "test.elf")
        with open(elf_file, "wb") as f:
            # ELF magic: 0x7F 'E' 'L' 'F'
            f.write(b"\x7fELF")
            f.write(b"\x00" * 100)  # Padding
        assert is_elf_file(elf_file) is True

    def test_is_elf_file_invalid(self, temp_dir):
        """Test non-ELF file detection"""
        non_elf = os.path.join(temp_dir, "not_elf.bin")
        with open(non_elf, "wb") as f:
            f.write(b"NOT_ELF_CONTENT")
        assert is_elf_file(non_elf) is False

    def test_is_elf_file_too_small(self, temp_dir):
        """Test file too small for ELF header"""
        small_file = os.path.join(temp_dir, "small.elf")
        with open(small_file, "wb") as f:
            f.write(b"\x7fE")  # Only 2 bytes
        assert is_elf_file(small_file) is False

    def test_is_elf_file_nonexistent(self):
        """Test nonexistent file"""
        assert is_elf_file("/nonexistent/path/file.elf") is False


# ============================================================
# Test: Color and Display
# ============================================================


class TestColorOutput:
    """Tests for color output"""

    def test_color_codes_exist(self):
        """Test that color codes are defined"""
        assert Colors.RED != ""
        assert Colors.GREEN != ""
        assert Colors.NC != ""

    def test_color_disable(self):
        """Test color disabling"""
        # Save original values
        orig_red = Colors.RED

        Colors.disable()

        assert Colors.RED == ""
        assert Colors.GREEN == ""
        assert Colors.NC == ""

        # Restore (for other tests)
        Colors.RED = orig_red
        # Note: In real usage, colors should be reset properly


# ============================================================
# Test: Integration
# ============================================================


class TestIntegration:
    """Integration tests"""

    def test_full_quality_report(self, temp_dir):
        """Test full quality report generation"""
        # Create multiple test files
        for i in range(3):
            content = f"""// File {i}
void func_{i}(void) {{
    int x = {i};
    return;
}}
"""
            with open(os.path.join(temp_dir, f"file_{i}.cpp"), "w") as f:
                f.write(content)

        project = analyze_directory(temp_dir)

        assert project.total_files == 3
        assert project.avg_quality_score > 0


# ============================================================
# Test: Edge Cases
# ============================================================


class TestEdgeCases:
    """Edge case tests"""

    def test_empty_directory(self, temp_dir):
        """Test analyzing empty directory"""
        project = analyze_directory(temp_dir)
        assert project.total_files == 0

    def test_nonexistent_file(self):
        """Test analyzing nonexistent file"""
        metrics = analyze_file("/nonexistent/path/file.cpp")
        assert len(metrics.issues) > 0

    def test_binary_file(self, temp_dir):
        """Test handling binary files"""
        binary_file = os.path.join(temp_dir, "binary.cpp")
        with open(binary_file, "wb") as f:
            f.write(b"\x00\x01\x02\x03\xff\xfe\xfd")

        # Should not crash
        metrics = analyze_file(binary_file)
        assert metrics is not None


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
