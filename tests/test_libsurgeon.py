#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LibSurgeon Test Suite

Unit tests for LibSurgeon decompilation tools.
Supports code coverage via pytest-cov.

Usage:
    pytest tests/                           # Run all tests
    pytest tests/ -v                        # Verbose output
    pytest tests/ --cov=. --cov-report=html # With coverage report
"""

import os
import shutil
import subprocess
import tempfile

import pytest

from evaluate_quality import (
    PATTERNS,
    FileMetrics,
    analyze_directory,
    analyze_file,
)
from ghidra_common import (
    extract_function_signature,
    generate_header_file,
    generate_master_header,
    generate_types_header,
    normalize_code_types,
    sanitize_filename,
)
from libsurgeon import (
    ELF_MACHINE_MAP,
    MODULE_STRATEGIES,
    Colors,
    FileType,
    detect_elf_architecture,
    draw_progress_bar,
    extract_archive,
    format_time,
    get_file_type,
    is_archive_file,
    is_elf_file,
    matches_pattern,
)

# Path setup is done in conftest.py


# ============================================================
# Fixtures
# ============================================================


@pytest.fixture
def temp_dir():
    """Create a temporary directory for tests"""
    tmp = tempfile.mkdtemp(prefix="libsurgeon_test_")
    yield tmp
    shutil.rmtree(tmp, ignore_errors=True)


@pytest.fixture
def sample_cpp_file(temp_dir):
    """Create a sample decompiled C++ file"""
    content = """/**
 * Auto-generated decompiled code from: TestModule.o
 * Generated by LibSurgeon (Ghidra-based decompiler)
 */

#include <stdint.h>
#include <stdbool.h>

namespace xxgfx {

// ============================================================
// Class: TestClass
// ============================================================

// Function: testFunction

void __thiscall TestClass::testFunction(TestClass *this, int param_1)
{
    undefined4 local_10;
    local_10 = *(undefined4 *)(this + 8);
    if (param_1 == 0) {
        __assert_fail("param != 0", "framework/source/test.cpp", 42, "void test()");
    }
    return;
}

// Function: anotherFunction

int TestClass::anotherFunction(void)
{
    return *(int *)(this + 0x10);
}

} // namespace xxgfx
"""
    filepath = os.path.join(temp_dir, "TestModule.cpp")
    with open(filepath, "w") as f:
        f.write(content)
    return filepath


@pytest.fixture
def sample_bad_cpp_file(temp_dir):
    """Create a sample decompiled file with quality issues"""
    content = """/**
 * Auto-generated with issues
 */

void bad_function(void)
{
    halt_baddata();
    halt_baddata();
    undefined4 local_10;
    undefined8 local_20;
    undefined local_30;
    goto LAB_001234;
LAB_001234:
    return;
}
"""
    filepath = os.path.join(temp_dir, "BadModule.cpp")
    with open(filepath, "w") as f:
        f.write(content)
    return filepath


@pytest.fixture
def sample_c_file(temp_dir):
    """Create a sample decompiled C file (not C++)"""
    content = """/**
 * Auto-generated decompiled C code
 * Generated by LibSurgeon
 */

#include <stdint.h>

// Function: simple_c_function

int simple_c_function(int param)
{
    int result = param * 2;
    return result;
}

// Function: another_c_function

void another_c_function(void)
{
    return;
}
"""
    filepath = os.path.join(temp_dir, "c_module.c")
    with open(filepath, "w") as f:
        f.write(content)
    return filepath


@pytest.fixture
def test_archive(temp_dir):
    """Create a minimal test archive if ar is available"""
    # Create a simple C file
    c_file = os.path.join(temp_dir, "test.c")
    with open(c_file, "w") as f:
        f.write("int test_func(void) { return 42; }\n")

    # Compile to object file
    o_file = os.path.join(temp_dir, "test.o")
    try:
        subprocess.run(
            ["gcc", "-c", c_file, "-o", o_file], check=True, capture_output=True
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("gcc not available")

    # Create archive
    a_file = os.path.join(temp_dir, "libtest.a")
    try:
        subprocess.run(["ar", "rcs", a_file, o_file], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("ar not available")

    return a_file


# ============================================================
# Test: File Type Detection
# ============================================================


class TestFileTypeDetection:
    """Tests for file type detection"""

    def test_archive_extensions(self):
        """Test archive file type detection"""
        assert get_file_type("libfoo.a") == FileType.ARCHIVE
        assert get_file_type("libbar.lib") == FileType.ARCHIVE
        assert get_file_type("/path/to/test.a") == FileType.ARCHIVE

    def test_elf_extensions(self):
        """Test ELF file type detection"""
        assert get_file_type("firmware.elf") == FileType.ELF
        assert get_file_type("libfoo.so") == FileType.ELF
        assert get_file_type("module.o") == FileType.ELF
        assert get_file_type("app.axf") == FileType.ELF
        assert get_file_type("program.out") == FileType.ELF

    def test_so_versioned(self):
        """Test versioned .so files"""
        assert get_file_type("libfoo.so.1") == FileType.ELF
        assert get_file_type("libfoo.so.1.2.3") == FileType.ELF

    def test_unknown_extensions(self):
        """Test unknown file types"""
        assert get_file_type("file.txt") == FileType.UNKNOWN
        assert get_file_type("image.png") == FileType.UNKNOWN
        assert get_file_type("code.cpp") == FileType.UNKNOWN


class TestPatternMatching:
    """Tests for pattern matching"""

    def test_exact_match(self):
        """Test exact filename matching"""
        assert matches_pattern("libfoo.a", "libfoo.a") is True
        assert matches_pattern("libfoo.a", "libbar.a") is False

    def test_wildcard_match(self):
        """Test wildcard pattern matching"""
        assert matches_pattern("libfoo.a", "lib*.a") is True
        assert matches_pattern("libfoo.a", "*.a") is True
        assert matches_pattern("libfoo.a", "libfoo.*") is True
        assert matches_pattern("libfoo.a", "*.so") is False

    def test_question_mark(self):
        """Test single character wildcard"""
        assert matches_pattern("libfoo.a", "libfo?.a") is True
        assert matches_pattern("libfoo.a", "lib???.a") is True
        assert matches_pattern("libfoo.a", "lib??.a") is False


class TestTimeFormatting:
    """Tests for time formatting"""

    def test_seconds(self):
        """Test seconds formatting"""
        assert format_time(0) == "0s"
        assert format_time(30) == "30s"
        assert format_time(59) == "59s"

    def test_minutes(self):
        """Test minutes formatting"""
        assert format_time(60) == "1m0s"
        assert format_time(90) == "1m30s"
        assert format_time(3599) == "59m59s"

    def test_hours(self):
        """Test hours formatting"""
        assert format_time(3600) == "1h0m"
        assert format_time(5400) == "1h30m"
        assert format_time(7200) == "2h0m"


class TestProgressBar:
    """Tests for progress bar functions"""

    def test_draw_progress_bar_empty(self):
        """Test empty progress bar"""
        bar = draw_progress_bar(0, 100)
        assert len(bar) == 40
        assert "█" not in bar
        assert bar.count("░") == 40

    def test_draw_progress_bar_full(self):
        """Test full progress bar"""
        bar = draw_progress_bar(100, 100)
        assert len(bar) == 40
        assert bar.count("█") == 40
        assert "░" not in bar

    def test_draw_progress_bar_half(self):
        """Test half-filled progress bar"""
        bar = draw_progress_bar(50, 100)
        assert len(bar) == 40
        assert bar.count("█") == 20
        assert bar.count("░") == 20

    def test_draw_progress_bar_zero_total(self):
        """Test progress bar with zero total"""
        bar = draw_progress_bar(0, 0)
        assert len(bar) == 40
        assert bar.count("░") == 40

    def test_draw_progress_bar_custom_width(self):
        """Test progress bar with custom width"""
        bar = draw_progress_bar(50, 100, width=20)
        assert len(bar) == 20


class TestModuleStrategies:
    """Tests for ELF module grouping strategies"""

    def test_strategies_defined(self):
        """Test that all strategies are defined"""
        assert "prefix" in MODULE_STRATEGIES
        assert "alpha" in MODULE_STRATEGIES
        assert "camelcase" in MODULE_STRATEGIES
        assert "single" in MODULE_STRATEGIES
        assert len(MODULE_STRATEGIES) == 4


# ============================================================
# Test: Quality Evaluation
# ============================================================


class TestQualityEvaluation:
    """Tests for quality evaluation"""

    def test_analyze_good_file(self, sample_cpp_file):
        """Test analyzing a good quality file"""
        metrics = analyze_file(sample_cpp_file)

        assert metrics.halt_baddata == 0
        assert metrics.lines > 0
        assert metrics.quality_score >= 80
        assert "xxgfx" in metrics.namespaces_found

    def test_analyze_bad_file(self, sample_bad_cpp_file):
        """Test analyzing a file with quality issues"""
        metrics = analyze_file(sample_bad_cpp_file)

        assert metrics.halt_baddata == 2
        assert metrics.goto_statements >= 1
        assert metrics.quality_score < 80
        assert len(metrics.issues) > 0

    def test_analyze_directory(self, sample_cpp_file, sample_bad_cpp_file, temp_dir):
        """Test analyzing a directory of files"""
        project = analyze_directory(temp_dir)

        assert project.total_files == 2
        assert project.files_with_halt_baddata == 1
        assert project.total_halt_baddata == 2
        assert 0 <= project.avg_quality_score <= 100

    def test_analyze_directory_with_c_files(
        self, sample_cpp_file, sample_c_file, temp_dir
    ):
        """Test analyzing a directory with both .c and .cpp files"""
        # Default pattern *.c* should match both .c and .cpp
        project = analyze_directory(temp_dir)

        assert project.total_files == 2
        # Check that both files were analyzed
        filenames = [m.filename for m in project.file_metrics]
        assert any(".c" in f and ".cpp" not in f for f in filenames)  # Has .c file
        assert any(".cpp" in f for f in filenames)  # Has .cpp file

    def test_analyze_directory_cpp_only_pattern(
        self, sample_cpp_file, sample_c_file, temp_dir
    ):
        """Test analyzing directory with explicit *.cpp pattern"""
        project = analyze_directory(temp_dir, file_pattern="*.cpp")

        # Should only find .cpp files
        assert project.total_files == 1
        assert project.file_metrics[0].filename.endswith(".cpp")

    def test_analyze_directory_c_only_pattern(
        self, sample_cpp_file, sample_c_file, temp_dir
    ):
        """Test analyzing directory with explicit *.c pattern (matches both .c and .cpp)"""
        # Note: *.c pattern in glob matches files ending with .c
        # but *.c also matches .cpp on some systems, so we test explicit behavior
        project = analyze_directory(temp_dir, file_pattern="*.c")

        # *.c should only match .c files (not .cpp)
        assert project.total_files >= 1

    def test_quality_score_calculation(self):
        """Test quality score calculation"""
        metrics = FileMetrics(filepath="test.cpp", filename="test.cpp")

        # Perfect file
        metrics.halt_baddata = 0
        metrics.undefined_types = 0
        assert metrics.quality_score >= 95

        # File with halt_baddata
        metrics.halt_baddata = 5
        assert metrics.quality_score < 60

    def test_pattern_detection(self):
        """Test regex pattern detection"""
        test_code = """
void test() {
    halt_baddata();
    undefined4 x;
    undefined8 y;
    goto LAB_001;
}
"""
        assert len(PATTERNS["halt_baddata"].findall(test_code)) == 1
        assert len(PATTERNS["undefined_type"].findall(test_code)) == 2
        assert len(PATTERNS["goto"].findall(test_code)) == 1


# ============================================================
# Test: Archive Processing
# ============================================================


class TestArchiveProcessing:
    """Tests for archive processing"""

    def test_extract_archive(self, test_archive, temp_dir):
        """Test archive extraction"""
        extract_dir = os.path.join(temp_dir, "extracted")
        obj_files = extract_archive(test_archive, extract_dir)

        assert len(obj_files) >= 1
        assert any(f.endswith(".o") for f in obj_files)

    def test_extract_archive_relative_path(self, test_archive, temp_dir):
        """Test archive extraction with relative path"""
        # Change to a different directory and use relative path
        orig_dir = os.getcwd()
        try:
            parent_dir = os.path.dirname(test_archive)
            archive_name = os.path.basename(test_archive)
            os.chdir(parent_dir)

            # Use relative path for archive
            extract_dir = os.path.join(temp_dir, "extracted_rel")
            obj_files = extract_archive(archive_name, extract_dir)

            assert len(obj_files) >= 1
            assert any(f.endswith(".o") for f in obj_files)
        finally:
            os.chdir(orig_dir)

    def test_is_archive_file(self, test_archive, temp_dir):
        """Test archive magic number detection"""
        assert is_archive_file(test_archive) is True

        # Create a non-archive file
        fake_file = os.path.join(temp_dir, "fake.a")
        with open(fake_file, "w") as f:
            f.write("not an archive")
        assert is_archive_file(fake_file) is False


class TestElfDetection:
    """Tests for ELF file detection"""

    def test_is_elf_file_valid(self, temp_dir):
        """Test valid ELF magic number detection"""
        # Create a file with ELF magic number
        elf_file = os.path.join(temp_dir, "test.elf")
        with open(elf_file, "wb") as f:
            # ELF magic: 0x7F 'E' 'L' 'F'
            f.write(b"\x7fELF")
            f.write(b"\x00" * 100)  # Padding
        assert is_elf_file(elf_file) is True

    def test_is_elf_file_invalid(self, temp_dir):
        """Test non-ELF file detection"""
        non_elf = os.path.join(temp_dir, "not_elf.bin")
        with open(non_elf, "wb") as f:
            f.write(b"NOT_ELF_CONTENT")
        assert is_elf_file(non_elf) is False

    def test_is_elf_file_too_small(self, temp_dir):
        """Test file too small for ELF header"""
        small_file = os.path.join(temp_dir, "small.elf")
        with open(small_file, "wb") as f:
            f.write(b"\x7fE")  # Only 2 bytes
        assert is_elf_file(small_file) is False

    def test_is_elf_file_nonexistent(self):
        """Test nonexistent file"""
        assert is_elf_file("/nonexistent/path/file.elf") is False


class TestElfArchitectureDetection:
    """Tests for ELF architecture detection"""

    def test_detect_arm32_little_endian(self, temp_dir):
        """Test ARM 32-bit little endian detection"""
        elf_file = os.path.join(temp_dir, "arm32le.o")
        with open(elf_file, "wb") as f:
            # ELF header for ARM 32-bit LE
            # Magic
            f.write(b"\x7fELF")
            # EI_CLASS: 1 = 32-bit
            f.write(b"\x01")
            # EI_DATA: 1 = little endian
            f.write(b"\x01")
            # EI_VERSION, EI_OSABI, EI_ABIVERSION, padding
            f.write(b"\x01\x00\x00" + b"\x00" * 7)
            # e_type (2 bytes): 1 = relocatable
            f.write(b"\x01\x00")
            # e_machine (2 bytes): 0x28 = ARM
            f.write(b"\x28\x00")
            # Rest of header
            f.write(b"\x00" * 100)

        result = detect_elf_architecture(elf_file)
        assert result is not None
        processor, cspec = result
        assert "ARM" in processor
        assert "LE" in processor
        assert "32" in processor

    def test_detect_arm64_little_endian(self, temp_dir):
        """Test ARM 64-bit (AARCH64) detection"""
        elf_file = os.path.join(temp_dir, "arm64le.o")
        with open(elf_file, "wb") as f:
            # ELF header for AARCH64
            f.write(b"\x7fELF")
            # EI_CLASS: 2 = 64-bit
            f.write(b"\x02")
            # EI_DATA: 1 = little endian
            f.write(b"\x01")
            f.write(b"\x01\x00\x00" + b"\x00" * 7)
            # e_type (2 bytes)
            f.write(b"\x01\x00")
            # e_machine (2 bytes): 0xB7 = AARCH64
            f.write(b"\xb7\x00")
            f.write(b"\x00" * 100)

        result = detect_elf_architecture(elf_file)
        assert result is not None
        processor, cspec = result
        assert "AARCH64" in processor
        assert "LE" in processor
        assert "64" in processor

    def test_detect_x86_32(self, temp_dir):
        """Test x86 32-bit detection"""
        elf_file = os.path.join(temp_dir, "x86_32.o")
        with open(elf_file, "wb") as f:
            f.write(b"\x7fELF")
            f.write(b"\x01")  # 32-bit
            f.write(b"\x01")  # little endian
            f.write(b"\x01\x00\x00" + b"\x00" * 7)
            f.write(b"\x01\x00")
            # e_machine: 0x03 = EM_386
            f.write(b"\x03\x00")
            f.write(b"\x00" * 100)

        result = detect_elf_architecture(elf_file)
        assert result is not None
        processor, cspec = result
        assert "x86" in processor
        assert "32" in processor

    def test_detect_x86_64(self, temp_dir):
        """Test x86-64 detection"""
        elf_file = os.path.join(temp_dir, "x86_64.o")
        with open(elf_file, "wb") as f:
            f.write(b"\x7fELF")
            f.write(b"\x02")  # 64-bit
            f.write(b"\x01")  # little endian
            f.write(b"\x01\x00\x00" + b"\x00" * 7)
            f.write(b"\x01\x00")
            # e_machine: 0x3E = EM_X86_64
            f.write(b"\x3e\x00")
            f.write(b"\x00" * 100)

        result = detect_elf_architecture(elf_file)
        assert result is not None
        processor, cspec = result
        assert "x86" in processor
        assert "64" in processor

    def test_detect_riscv32(self, temp_dir):
        """Test RISC-V 32-bit detection"""
        elf_file = os.path.join(temp_dir, "riscv32.o")
        with open(elf_file, "wb") as f:
            f.write(b"\x7fELF")
            f.write(b"\x01")  # 32-bit
            f.write(b"\x01")  # little endian
            f.write(b"\x01\x00\x00" + b"\x00" * 7)
            f.write(b"\x01\x00")
            # e_machine: 0xF3 = EM_RISCV
            f.write(b"\xf3\x00")
            f.write(b"\x00" * 100)

        result = detect_elf_architecture(elf_file)
        assert result is not None
        processor, cspec = result
        assert "RISCV" in processor
        assert "32" in processor

    def test_detect_nonexistent_file(self):
        """Test detection on nonexistent file"""
        result = detect_elf_architecture("/nonexistent/path/file.o")
        assert result is None

    def test_detect_non_elf_file(self, temp_dir):
        """Test detection on non-ELF file"""
        non_elf = os.path.join(temp_dir, "not_elf.bin")
        with open(non_elf, "wb") as f:
            f.write(b"NOT_ELF_CONTENT")
        result = detect_elf_architecture(non_elf)
        assert result is None

    def test_elf_machine_map_exists(self):
        """Test that ELF machine map has expected entries"""
        # Check some common architectures are mapped
        assert 0x03 in ELF_MACHINE_MAP  # x86
        assert 0x3E in ELF_MACHINE_MAP  # x86-64
        assert 0x28 in ELF_MACHINE_MAP  # ARM
        assert 0xB7 in ELF_MACHINE_MAP  # AARCH64
        assert 0xF3 in ELF_MACHINE_MAP  # RISC-V


# ============================================================
# Test: Color and Display
# ============================================================


class TestColorOutput:
    """Tests for color output"""

    def test_color_codes_exist(self):
        """Test that color codes are defined"""
        assert Colors.RED != ""
        assert Colors.GREEN != ""
        assert Colors.NC != ""

    def test_color_disable(self):
        """Test color disabling"""
        # Save original values
        orig_red = Colors.RED

        Colors.disable()

        assert Colors.RED == ""
        assert Colors.GREEN == ""
        assert Colors.NC == ""

        # Restore (for other tests)
        Colors.RED = orig_red
        # Note: In real usage, colors should be reset properly


# ============================================================
# Test: Integration
# ============================================================


class TestIntegration:
    """Integration tests"""

    def test_full_quality_report(self, temp_dir):
        """Test full quality report generation"""
        # Create multiple test files
        for i in range(3):
            content = f"""// File {i}
void func_{i}(void) {{
    int x = {i};
    return;
}}
"""
            with open(os.path.join(temp_dir, f"file_{i}.cpp"), "w") as f:
                f.write(content)

        project = analyze_directory(temp_dir)

        assert project.total_files == 3
        assert project.avg_quality_score > 0


# ============================================================
# Test: Edge Cases
# ============================================================


class TestEdgeCases:
    """Edge case tests"""

    def test_empty_directory(self, temp_dir):
        """Test analyzing empty directory"""
        project = analyze_directory(temp_dir)
        assert project.total_files == 0

    def test_nonexistent_file(self):
        """Test analyzing nonexistent file"""
        metrics = analyze_file("/nonexistent/path/file.cpp")
        assert len(metrics.issues) > 0

    def test_binary_file(self, temp_dir):
        """Test handling binary files"""
        binary_file = os.path.join(temp_dir, "binary.cpp")
        with open(binary_file, "wb") as f:
            f.write(b"\x00\x01\x02\x03\xff\xfe\xfd")

        # Should not crash
        metrics = analyze_file(binary_file)
        assert metrics is not None


# ============================================================
# Test: C++ Class/Struct/VTable Analysis
# ============================================================


class TestCppClassAnalysis:
    """Tests for C++ class, struct, and vtable analysis functions"""

    def test_extract_class_from_method_basic(self):
        """Test basic class extraction from method signatures"""
        # Create a minimal mock module for ghidra_decompile_elf
        # We only need to test the pure Python functions
        code = r'''
import re

def extract_class_from_method(display_name):
    """
    Extract class name from a method signature.
    """
    # Remove return type prefix
    match = re.match(r"(?:[\w\s\*]+\s+)?(?:__thiscall\s+)?(\w+(?:::\w+)*)::(\w+)\s*\(", display_name)
    if match:
        return match.group(1)

    # Try simpler pattern for mangled names
    if "::" in display_name:
        parts = display_name.split("::")
        if len(parts) >= 2:
            # Return everything except the last part (method name)
            return "::".join(parts[:-1]).split("(")[0].strip()

    return None
'''
        # Execute the function definition
        local_ns = {}
        exec(code, local_ns)
        extract_class_from_method = local_ns["extract_class_from_method"]

        # Test cases
        assert extract_class_from_method("void CoreView::Draw(void)") == "CoreView"
        assert extract_class_from_method("int CoreView::GetWidth(void)") == "CoreView"
        assert (
            extract_class_from_method("void __thiscall CoreView::Init(CoreView *this)")
            == "CoreView"
        )

    def test_extract_class_from_method_namespace(self):
        """Test class extraction with namespaces"""
        import re

        def extract_class_from_method(display_name):
            match = re.match(
                r"(?:[\w\s\*]+\s+)?(?:__thiscall\s+)?(\w+(?:::\w+)*)::\w+\s*\(",
                display_name,
            )
            if match:
                return match.group(1)
            if "::" in display_name:
                parts = display_name.split("::")
                if len(parts) >= 2:
                    return "::".join(parts[:-1]).split("(")[0].strip()
            return None

        # Nested namespace
        assert (
            extract_class_from_method("void Namespace::Class::Method(int)")
            == "Namespace::Class"
        )
        assert extract_class_from_method("void A::B::C::Method(void)") == "A::B::C"

    def test_extract_class_from_method_no_class(self):
        """Test that non-class functions return None"""
        import re

        def extract_class_from_method(display_name):
            match = re.match(
                r"(?:[\w\s\*]+\s+)?(?:__thiscall\s+)?(\w+(?:::\w+)*)::\w+\s*\(",
                display_name,
            )
            if match:
                return match.group(1)
            if "::" in display_name:
                parts = display_name.split("::")
                if len(parts) >= 2:
                    return "::".join(parts[:-1]).split("(")[0].strip()
            return None

        # Regular C functions
        assert extract_class_from_method("void main(void)") is None
        assert extract_class_from_method("int printf(const char *)") is None
        assert extract_class_from_method("FUN_00123456") is None

    def test_cpp_class_info_structure(self):
        """Test CppClassInfo data structure"""

        class CppClassInfo:
            def __init__(self, name):
                self.name = name
                self.methods = []
                self.vtable_addr = None
                self.vtable_funcs = []
                self.struct_type = None
                self.parent_class = None
                self.size = 0

        # Create a class info
        cls = CppClassInfo("TestClass")
        cls.methods.append(("_ZN9TestClass4initEv", "init", True, 0))
        cls.methods.append(("_ZN9TestClass4drawEv", "draw", True, 1))
        cls.methods.append(("_ZN9TestClass6updateEv", "update", False, -1))

        assert cls.name == "TestClass"
        assert len(cls.methods) == 3

        # Count virtual methods
        virtual_count = sum(1 for _, _, is_v, _ in cls.methods if is_v)
        assert virtual_count == 2

    def test_enhance_decompiled_code_field_annotation(self):
        """Test field access annotation in decompiled code"""
        import re

        def enhance_decompiled_code(code, class_info_map, struct_info_map):
            if not code:
                return code
            enhanced = code
            field_pattern = r"(field_0x[0-9a-fA-F]+)"
            matches = re.findall(field_pattern, enhanced)
            if matches:
                unique_fields = set(matches)
                if len(unique_fields) > 3:
                    hint = "// NOTE: {} unknown struct fields accessed - consider defining struct type\n".format(
                        len(unique_fields)
                    )
                    brace_pos = enhanced.find("{")
                    if brace_pos > 0:
                        enhanced = (
                            enhanced[: brace_pos + 1]
                            + "\n"
                            + hint
                            + enhanced[brace_pos + 1 :]
                        )
            return enhanced

        # Test with many unknown fields
        code = """void TestFunc(void *obj) {
    int a = obj->field_0x10;
    int b = obj->field_0x14;
    int c = obj->field_0x18;
    int d = obj->field_0x1c;
    int e = obj->field_0x20;
}"""
        enhanced = enhance_decompiled_code(code, {}, {})
        assert "NOTE:" in enhanced
        assert "unknown struct fields" in enhanced

    def test_enhance_decompiled_code_few_fields(self):
        """Test that few fields don't trigger annotation"""
        import re

        def enhance_decompiled_code(code, class_info_map, struct_info_map):
            if not code:
                return code
            enhanced = code
            field_pattern = r"(field_0x[0-9a-fA-F]+)"
            matches = re.findall(field_pattern, enhanced)
            if matches:
                unique_fields = set(matches)
                if len(unique_fields) > 3:
                    hint = "// NOTE: {} unknown struct fields accessed\n".format(
                        len(unique_fields)
                    )
                    brace_pos = enhanced.find("{")
                    if brace_pos > 0:
                        enhanced = (
                            enhanced[: brace_pos + 1]
                            + "\n"
                            + hint
                            + enhanced[brace_pos + 1 :]
                        )
            return enhanced

        # Test with few fields - should not add note
        code = """void TestFunc(void *obj) {
    int a = obj->field_0x10;
    int b = obj->field_0x14;
}"""
        enhanced = enhance_decompiled_code(code, {}, {})
        assert "NOTE:" not in enhanced

    def test_vtable_pattern_matching(self):
        """Test vtable symbol pattern recognition"""
        import re

        vtable_patterns = [
            r"^_ZTV",  # Itanium ABI: _ZTV<class>
            r"^vtable\s+for\s+",  # Demangled vtable
            r"^__vt_",  # Some compilers
            r"_vtbl$",  # ARM/RVCT pattern
        ]

        def is_vtable_symbol(name):
            for pattern in vtable_patterns:
                if re.search(pattern, name, re.IGNORECASE):
                    return True
            return False

        # Test Itanium ABI pattern
        assert is_vtable_symbol("_ZTV9CoreView") is True
        assert is_vtable_symbol("_ZTV12ApplicationApp") is True

        # Test demangled pattern
        assert is_vtable_symbol("vtable for CoreView") is True

        # Test old compiler patterns
        assert is_vtable_symbol("__vt_CoreView") is True
        assert is_vtable_symbol("CoreView_vtbl") is True

        # Non-vtable symbols
        assert is_vtable_symbol("_ZN9CoreView4drawEv") is False
        assert is_vtable_symbol("main") is False
        assert is_vtable_symbol("FUN_00123456") is False

    def test_vtable_class_name_extraction(self):
        """Test extracting class name from vtable symbol"""

        def extract_vtable_class_name(sym_name):
            if sym_name.startswith("_ZTV"):
                # For real demangling we'd use Ghidra, simulate here
                # _ZTV9CoreView -> CoreView (9 = length)
                remaining = sym_name[4:]  # Remove _ZTV
                # Simple extraction - in real code this uses demangler
                return remaining
            if "vtable for " in sym_name:
                return sym_name.replace("vtable for ", "").strip()
            if sym_name.startswith("__vt_"):
                return sym_name[5:]  # Remove __vt_
            if sym_name.endswith("_vtbl"):
                return sym_name[:-5]  # Remove _vtbl
            return None

        assert extract_vtable_class_name("_ZTV9CoreView") == "9CoreView"  # Mangled
        assert extract_vtable_class_name("vtable for CoreView") == "CoreView"
        assert extract_vtable_class_name("__vt_CoreView") == "CoreView"
        assert extract_vtable_class_name("CoreView_vtbl") == "CoreView"

    def test_virtual_method_detection_by_thiscall(self):
        """Test virtual method detection via calling convention"""

        def is_likely_virtual_by_convention(calling_conv):
            if calling_conv and "thiscall" in calling_conv.lower():
                return True
            return False

        assert is_likely_virtual_by_convention("__thiscall") is True
        assert is_likely_virtual_by_convention("thiscall") is True
        assert is_likely_virtual_by_convention("THISCALL") is True
        assert is_likely_virtual_by_convention("cdecl") is False
        assert is_likely_virtual_by_convention("stdcall") is False
        assert is_likely_virtual_by_convention(None) is False

    def test_class_header_content(self):
        """Test generated class header structure"""

        class CppClassInfo:
            def __init__(self, name):
                self.name = name
                self.methods = []
                self.vtable_addr = None
                self.vtable_funcs = []

        def generate_class_header_content(classes):
            lines = []
            lines.append("/* C++ Class Analysis */")
            lines.append("#ifndef _CLASSES_H_")
            lines.append("#define _CLASSES_H_")
            lines.append("")

            for class_name in sorted(classes.keys()):
                cls = classes[class_name]
                safe_name = class_name.replace("::", "_")
                lines.append("/* Class: {} */".format(class_name))
                lines.append("typedef struct {} {};".format(safe_name, safe_name))

                if cls.vtable_funcs:
                    lines.append(
                        "/* Virtual methods: {} */".format(len(cls.vtable_funcs))
                    )

                for mangled, method_name, is_virtual, vt_idx in cls.methods:
                    marker = "[virtual:{}]".format(vt_idx) if is_virtual else ""
                    lines.append("/* {} {} */".format(marker, method_name))
                lines.append("")

            lines.append("#endif")
            return "\n".join(lines)

        # Create test classes
        classes = {}
        cls1 = CppClassInfo("CoreView")
        cls1.methods = [
            ("_ZN8CoreView4DrawEv", "Draw", True, 0),
            ("_ZN8CoreView4InitEv", "Init", False, -1),
        ]
        cls1.vtable_funcs = [(0, None, "Draw")]
        classes["CoreView"] = cls1

        content = generate_class_header_content(classes)

        assert "Class: CoreView" in content
        assert "typedef struct CoreView CoreView" in content
        assert "[virtual:0]" in content
        assert "Draw" in content


# ============================================================
# Test: All Supported File Types
# ============================================================


class TestAllSupportedFileTypes:
    """Tests for all supported file types using real fixture files"""

    @pytest.fixture
    def fixtures_dir(self):
        """Return the fixtures directory path"""
        return os.path.join(os.path.dirname(__file__), "fixtures")

    def test_fixture_files_exist(self, fixtures_dir):
        """Verify all expected fixture files exist"""
        expected_files = [
            "test_library.o",
            "libtest.a",
            "libtest.lib",
            "libtest.so",
            "libtest.so.1.0.0",
            "test_program.elf",
            "test_program.axf",
            "test_program.out",
        ]
        for filename in expected_files:
            filepath = os.path.join(fixtures_dir, filename)
            assert os.path.exists(filepath), f"Fixture file missing: {filename}"

    # --- Archive Type Tests ---

    def test_archive_a_detection(self, fixtures_dir):
        """Test .a archive file detection"""
        filepath = os.path.join(fixtures_dir, "libtest.a")
        assert get_file_type(filepath) == FileType.ARCHIVE
        assert is_archive_file(filepath) is True
        assert is_elf_file(filepath) is False

    def test_archive_lib_detection(self, fixtures_dir):
        """Test .lib archive file detection"""
        filepath = os.path.join(fixtures_dir, "libtest.lib")
        assert get_file_type(filepath) == FileType.ARCHIVE
        assert is_archive_file(filepath) is True
        assert is_elf_file(filepath) is False

    # --- ELF Type Tests ---

    def test_elf_o_detection(self, fixtures_dir):
        """Test .o object file detection"""
        filepath = os.path.join(fixtures_dir, "test_library.o")
        assert get_file_type(filepath) == FileType.ELF
        assert is_elf_file(filepath) is True
        assert is_archive_file(filepath) is False

    def test_elf_so_detection(self, fixtures_dir):
        """Test .so shared library detection"""
        filepath = os.path.join(fixtures_dir, "libtest.so")
        assert get_file_type(filepath) == FileType.ELF
        assert is_elf_file(filepath) is True
        assert is_archive_file(filepath) is False

    def test_elf_so_versioned_detection(self, fixtures_dir):
        """Test versioned .so.x.y.z shared library detection"""
        filepath = os.path.join(fixtures_dir, "libtest.so.1.0.0")
        assert get_file_type(filepath) == FileType.ELF
        assert is_elf_file(filepath) is True
        assert is_archive_file(filepath) is False

    def test_elf_elf_detection(self, fixtures_dir):
        """Test .elf executable detection"""
        filepath = os.path.join(fixtures_dir, "test_program.elf")
        assert get_file_type(filepath) == FileType.ELF
        assert is_elf_file(filepath) is True
        assert is_archive_file(filepath) is False

    def test_elf_axf_detection(self, fixtures_dir):
        """Test .axf ARM executable detection"""
        filepath = os.path.join(fixtures_dir, "test_program.axf")
        assert get_file_type(filepath) == FileType.ELF
        assert is_elf_file(filepath) is True
        assert is_archive_file(filepath) is False

    def test_elf_out_detection(self, fixtures_dir):
        """Test .out executable detection"""
        filepath = os.path.join(fixtures_dir, "test_program.out")
        assert get_file_type(filepath) == FileType.ELF
        assert is_elf_file(filepath) is True
        assert is_archive_file(filepath) is False

    # --- Archive Extraction Tests ---

    def test_archive_a_extraction(self, fixtures_dir, temp_dir):
        """Test extracting .a archive"""
        archive_path = os.path.join(fixtures_dir, "libtest.a")
        extract_archive(archive_path, temp_dir)
        # Check that .o file was extracted
        extracted = os.listdir(temp_dir)
        assert len(extracted) > 0
        assert any(f.endswith(".o") for f in extracted)

    def test_archive_lib_extraction(self, fixtures_dir, temp_dir):
        """Test extracting .lib archive"""
        archive_path = os.path.join(fixtures_dir, "libtest.lib")
        extract_archive(archive_path, temp_dir)
        # Check that .o file was extracted
        extracted = os.listdir(temp_dir)
        assert len(extracted) > 0
        assert any(f.endswith(".o") for f in extracted)

    # --- ELF Magic Number Verification ---

    def test_elf_magic_number_verification(self, fixtures_dir):
        """Verify ELF files have correct magic number"""
        elf_files = [
            "test_library.o",
            "libtest.so",
            "test_program.elf",
            "test_program.axf",
            "test_program.out",
        ]
        for filename in elf_files:
            filepath = os.path.join(fixtures_dir, filename)
            with open(filepath, "rb") as f:
                magic = f.read(4)
            assert magic == b"\x7fELF", f"{filename} does not have ELF magic"

    def test_archive_magic_number_verification(self, fixtures_dir):
        """Verify archive files have correct magic number"""
        archive_files = ["libtest.a", "libtest.lib"]
        for filename in archive_files:
            filepath = os.path.join(fixtures_dir, filename)
            with open(filepath, "rb") as f:
                magic = f.read(7)
            assert magic == b"!<arch>", f"{filename} does not have archive magic"

    # --- Unknown Type Tests ---

    def test_unknown_file_type(self, fixtures_dir):
        """Test that non-supported files are marked as UNKNOWN"""
        # test_library.c is a source file, not a binary
        filepath = os.path.join(fixtures_dir, "test_library.c")
        assert get_file_type(filepath) == FileType.UNKNOWN
        assert is_elf_file(filepath) is False
        assert is_archive_file(filepath) is False


# ============================================================
# Test: Header File Generation (ghidra_common)
# ============================================================


class TestHeaderGeneration:
    """Tests for header file generation functions in ghidra_common"""

    def test_extract_function_signature_simple(self):
        """Test extracting function signature from simple function"""
        code = """int my_function(int param1, char *param2)
{
    return 42;
}"""
        sig = extract_function_signature(code)
        assert sig is not None
        assert "my_function" in sig
        assert "int" in sig
        assert "param1" in sig

    def test_extract_function_signature_void(self):
        """Test extracting signature from void function"""
        code = """void empty_function(void)
{
}"""
        sig = extract_function_signature(code)
        assert sig is not None
        assert "void" in sig
        assert "empty_function" in sig

    def test_extract_function_signature_multiline(self):
        """Test extracting signature from multiline declaration"""
        code = """static int
multiline_function(int a,
                   int b,
                   int c)
{
    return a + b + c;
}"""
        sig = extract_function_signature(code)
        assert sig is not None
        assert "multiline_function" in sig

    def test_extract_function_signature_with_undefined(self):
        """Test that Ghidra types are normalized in signature"""
        code = """undefined4 process_data(undefined8 input)
{
    return 0;
}"""
        sig = extract_function_signature(code)
        assert sig is not None
        # Should be normalized to standard types
        assert "undefined4" not in sig or "unk32_t" in sig

    def test_extract_function_signature_empty(self):
        """Test extracting from empty/invalid code"""
        assert extract_function_signature("") is None
        assert extract_function_signature(None) is None
        assert extract_function_signature("   ") is None

    def test_extract_function_signature_variable_decl(self):
        """Test that variable declarations are rejected"""
        code = "int global_var;"
        sig = extract_function_signature(code)
        assert sig is None

    def test_generate_header_file(self, temp_dir):
        """Test generating a header file"""
        func_signatures = [
            ("my_func", "int my_func(int a, int b)"),
            ("another_func", "void another_func(void)"),
        ]
        header_path = generate_header_file(temp_dir, "test_module", func_signatures)

        assert os.path.isfile(header_path)
        assert header_path.endswith(".h")

        with open(header_path, "r") as f:
            content = f.read()

        assert "#ifndef" in content
        assert "#define" in content
        assert "#endif" in content
        assert "my_func" in content
        assert "another_func" in content
        assert 'extern "C"' in content

    def test_generate_header_file_with_source_type(self, temp_dir):
        """Test header file includes correct source type"""
        func_signatures = [("test_func", "int test_func(void)")]
        header_path = generate_header_file(
            temp_dir, "module", func_signatures, "custom source type"
        )

        with open(header_path, "r") as f:
            content = f.read()

        assert "custom source type" in content

    def test_generate_master_header(self, temp_dir):
        """Test generating master header file"""
        modules = ["module_a", "module_b", "module_c"]
        master_path = generate_master_header(temp_dir, modules, "test_program")

        assert os.path.isfile(master_path)
        assert "_all_headers.h" in master_path

        with open(master_path, "r") as f:
            content = f.read()

        assert "#ifndef _ALL_HEADERS_H_" in content
        assert "module_a.h" in content
        assert "module_b.h" in content
        assert "module_c.h" in content

    def test_generate_types_header(self, temp_dir):
        """Test generating types header file"""
        types_path = generate_types_header(temp_dir)

        assert os.path.isfile(types_path)
        assert types_path.endswith("_types.h")

        with open(types_path, "r") as f:
            content = f.read()

        assert "#ifndef _LIBSURGEON_TYPES_H_" in content
        assert "unk8_t" in content
        assert "unk32_t" in content
        assert "typedef" in content


class TestNormalizeCodeTypes:
    """Tests for type normalization functions"""

    def test_normalize_undefined_types(self):
        """Test normalization of Ghidra undefined types"""
        code = "undefined4 x = 0; undefined8 y = 1;"
        normalized = normalize_code_types(code)
        assert "undefined4" not in normalized
        assert "undefined8" not in normalized
        assert "unk32_t" in normalized
        assert "unk64_t" in normalized

    def test_normalize_basic_types(self):
        """Test normalization of Ghidra basic types"""
        code = "dword value; qword large;"
        normalized = normalize_code_types(code)
        assert "uint32_t" in normalized
        assert "uint64_t" in normalized

    def test_normalize_preserves_standard_types(self):
        """Test that standard C types are preserved"""
        code = "int32_t x; uint8_t y; void *ptr;"
        normalized = normalize_code_types(code)
        assert "int32_t" in normalized
        assert "uint8_t" in normalized
        assert "void *" in normalized


class TestSanitizeFilename:
    """Tests for filename sanitization"""

    def test_basic_sanitize(self):
        """Test basic filename sanitization"""
        assert sanitize_filename("hello") == "hello"
        assert sanitize_filename("test_file") == "test_file"

    def test_sanitize_special_chars(self):
        """Test sanitization of special characters"""
        result = sanitize_filename("test/file:name")
        assert "/" not in result
        assert ":" not in result

    def test_sanitize_spaces(self):
        """Test sanitization of spaces"""
        result = sanitize_filename("test file name")
        assert " " not in result


class TestDirectorySeparation:
    """Tests for src/include directory separation"""

    def test_header_files_in_include_dir(self, temp_dir):
        """Test that header files are generated in include directory, not src"""
        src_dir = os.path.join(temp_dir, "src")
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(src_dir, exist_ok=True)
        os.makedirs(include_dir, exist_ok=True)

        # Simulate header generation to include dir
        func_signatures = [("test_func", "int test_func(void)")]
        header_path = generate_header_file(include_dir, "module", func_signatures)

        # Header should be in include dir
        assert os.path.isfile(header_path)
        assert include_dir in header_path
        assert src_dir not in header_path

        # No headers in src dir
        src_headers = [f for f in os.listdir(src_dir) if f.endswith(".h")]
        assert len(src_headers) == 0

    def test_source_files_only_in_src_dir(self, temp_dir):
        """Test that source files go to src, headers to include"""
        src_dir = os.path.join(temp_dir, "src")
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(src_dir, exist_ok=True)
        os.makedirs(include_dir, exist_ok=True)

        # Create a source file in src dir
        source_file = os.path.join(src_dir, "module.cpp")
        with open(source_file, "w") as f:
            f.write("// Source code\nint main() { return 0; }\n")

        # Create a header file in include dir
        header_file = os.path.join(include_dir, "module.h")
        with open(header_file, "w") as f:
            f.write("#ifndef MODULE_H\n#define MODULE_H\n#endif\n")

        # Verify separation
        src_files = os.listdir(src_dir)
        include_files = os.listdir(include_dir)

        assert "module.cpp" in src_files
        assert "module.h" not in src_files
        assert "module.h" in include_files
        assert "module.cpp" not in include_files

    def test_types_header_in_include_dir(self, temp_dir):
        """Test that _types.h is generated in include directory"""
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(include_dir, exist_ok=True)

        types_path = generate_types_header(include_dir)

        assert os.path.isfile(types_path)
        assert types_path == os.path.join(include_dir, "_types.h")

    def test_master_header_includes_all_modules(self, temp_dir):
        """Test that master header includes all module headers"""
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(include_dir, exist_ok=True)

        # Create some module headers
        modules = ["module_a", "module_b", "module_c"]
        for module in modules:
            header_file = os.path.join(include_dir, f"{module}.h")
            with open(header_file, "w") as f:
                f.write(f"// Header for {module}\n")

        # Generate master header
        master_path = generate_master_header(include_dir, modules, "test_program")

        assert os.path.isfile(master_path)

        with open(master_path, "r") as f:
            content = f.read()

        for module in modules:
            assert f'#include "{module}.h"' in content


if __name__ == "__main__":
    pytest.main([__file__, "-v"])


# ============================================================
# Test: Code Cleaning Functions
# ============================================================


class TestCleanDecompiledCode:
    """Tests for clean_decompiled_code function"""

    def test_remove_function_signature_comment(self):
        """Test removal of function signature comments"""
        from ghidra_common import clean_decompiled_code

        code = """/* BESplitMatrix(sbematrix const*, sbevec3*, sbequat*, sbevec3*) */
void BESplitMatrix(sbematrix *param_1, sbevec3 *param_2)
{
    int x = 1;
    return;
}"""
        cleaned = clean_decompiled_code(code)
        assert "/* BESplitMatrix" not in cleaned
        assert "void BESplitMatrix" in cleaned

    def test_remove_simple_function_name_comment(self):
        """Test removal of simple function name comments"""
        from ghidra_common import clean_decompiled_code

        code = """/* TestFunc */
void TestFunc(void)
{
    return;
}"""
        cleaned = clean_decompiled_code(code)
        assert "/* TestFunc */" not in cleaned
        assert "void TestFunc" in cleaned

    def test_remove_blank_lines_inside_function(self):
        """Test removal of blank lines inside function body"""
        from ghidra_common import clean_decompiled_code

        code = """void TestFunc(void)

{

  int x;

  int y;

  x = 1;

  y = 2;

  return;

}"""
        cleaned = clean_decompiled_code(code)
        # Should have no blank lines inside the function
        lines = cleaned.split("\n")
        inside_braces = False
        blank_inside = 0
        for line in lines:
            if "{" in line:
                inside_braces = True
            if "}" in line:
                inside_braces = False
            if inside_braces and not line.strip():
                blank_inside += 1
        assert blank_inside == 0, f"Found {blank_inside} blank lines inside function"

    def test_preserve_blank_line_between_functions(self):
        """Test that one blank line is preserved between functions"""
        from ghidra_common import clean_decompiled_code

        code = """void Func1(void)
{
    return;
}

void Func2(void)
{
    return;
}"""
        cleaned = clean_decompiled_code(code)
        # Should have exactly one blank line between functions
        assert "\n\nvoid Func2" in cleaned or "}\n\nvoid" in cleaned

    def test_collapse_multiple_blank_lines_outside_function(self):
        """Test that multiple blank lines outside functions are collapsed to one"""
        from ghidra_common import clean_decompiled_code

        code = """void Func1(void)
{
    return;
}



void Func2(void)
{
    return;
}"""
        cleaned = clean_decompiled_code(code)
        # Should not have more than 2 consecutive newlines (one blank line)
        assert "\n\n\n" not in cleaned

    def test_handle_empty_code(self):
        """Test handling of empty or None code"""
        from ghidra_common import clean_decompiled_code

        assert clean_decompiled_code(None) is None
        assert clean_decompiled_code("") == ""

    def test_preserve_meaningful_comments(self):
        """Test that meaningful comments are preserved"""
        from ghidra_common import clean_decompiled_code

        code = """/* This is a meaningful comment about the function */
void TestFunc(void)
{
    return;
}"""
        cleaned = clean_decompiled_code(code)
        assert "meaningful comment" in cleaned

    def test_real_ghidra_output(self):
        """Test with real Ghidra-style output"""
        from ghidra_common import clean_decompiled_code

        code = """/* CMemStore::Alloc(unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned int) */

void * CMemStore::Alloc(uint param_1,undefined param_2,undefined param_3,undefined param_4,

                       undefined param_5,undefined param_6,undefined4 param_7)



{

  void *pvVar1;

  undefined4 in_register_0000003c;



  pvVar1 = operator_new__(CONCAT44(in_register_0000003c,param_1));

  return pvVar1;

}"""
        cleaned = clean_decompiled_code(code)

        # Should remove the signature comment
        assert "/* CMemStore::Alloc" not in cleaned

        # Should remove blank lines inside function
        lines = cleaned.split("\n")
        # Count lines - should be much fewer
        assert len(lines) < len(code.split("\n"))

        # Function should still be valid
        assert "void * CMemStore::Alloc" in cleaned
        assert "return pvVar1;" in cleaned

    def test_nested_braces(self):
        """Test handling of nested braces"""
        from ghidra_common import clean_decompiled_code

        code = """void TestFunc(void)
{

  if (x) {

    y = 1;

  }

  return;

}"""
        cleaned = clean_decompiled_code(code)
        # Should remove all internal blank lines
        assert "\n\n" not in cleaned.split("{", 1)[1].rsplit("}", 1)[0]


    def test_windows_line_endings(self):
        """Test handling of Windows CRLF line endings"""
        from ghidra_common import clean_decompiled_code

        # Simulate Windows CRLF output from Ghidra
        code = "void TestFunc(void)\r\n\r\n{\r\n\r\n  int x;\r\n\r\n  return;\r\n\r\n}\r\n"
        cleaned = clean_decompiled_code(code)
        
        # Should not have any \r characters
        assert "\r" not in cleaned
        
        # Should not have blank lines inside function
        lines = cleaned.split('\n')
        inside_braces = False
        for line in lines:
            if '{' in line:
                inside_braces = True
            if '}' in line:
                inside_braces = False
            if inside_braces and not line.strip():
                assert False, "Found blank line inside function body"
